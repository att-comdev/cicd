import com.att.nccicd.config.conf as config
conf = new config(env).CONF

import groovy.json.JsonSlurperClassic
import groovy.json.JsonOutput

IMAGE_PREFIX="att-comdev"
VERSION=1.0
GERRIT_CLONE_URL = "ssh://" + conf.SSH_REPO_USER + "@" + conf.GERRIT_URL
REFSPEC = "refs/changes/*:refs/changes/*"
ARTF_PATH = "minimirror/gpgkey-private"

currentBuild.displayName = "#${BUILD_NUMBER} ${GERRIT_EVENT_TYPE}"

IMAGE="${ARTF_DOCKER_URL}/${IMAGE_PREFIX}/mini-mirror:${GERRIT_PATCHSET_REVISION}-ubuntu_xenial"
IMAGE_LATEST="${ARTF_DOCKER_URL}/${IMAGE_PREFIX}/mini-mirror:latest"
IMAGE_DOCKER="${ARTF_DOCKER_URL}/${IMAGE_PREFIX}/mini-mirror:${GERRIT_PATCHSET_REVISION}-docker-ubuntu"
IMAGE_DOCKER_LATEST="${ARTF_DOCKER_URL}/${IMAGE_PREFIX}/mini-mirror:latest"

String determineRef(String repo) {

    // Determine if job was triggered by Gerrit
    if (env.GERRIT_EVENT_TYPE) {

        // Use master for if change was merged, otherwise use change revision
        if (env.GERRIT_EVENT_TYPE == "change-merged") {
            return "origin/master"
        } else {
            return env.GERRIT_NEWREV || env.GERRIT_PASTCHSET_REVISION
        }
    }

    // Job was triggered manually, determine which reference to use
    if (repo == "aic-clcp-manifests") {
        return params.CLCP_MANIFESTS_REF
    }

    return params.OSH_IMAGES_REF
}

def label = "worker-${UUID.randomUUID().toString()}"
podTemplate(label: label,yaml: """
            apiVersion: v1
            kind: Pod
            spec:
              securityContext:
                runAsUser: 0
              nodeSelector:
                dind-node: enabled
            """, containers: [
                containerTemplate(name: "ubuntu",
                                  image: "${ARTF_DOCKER_URL}/ubuntu_copy/18.04/nc-ubuntu-18.04@sha256:a08437dd42b2d095cef653d485414fe351401c55b480f16908d5911e4ba75c0f",
                                  command: "cat",
                                  ttyEnabled: true)],
                volumes: [hostPathVolume(hostPath: '/var/run/dindproxy/docker.sock', mountPath: '/var/run/docker.sock')]) {
    node(label){
        container("ubuntu"){

            stage("Setup environment"){
                sh "apt-get install sudo make docker.io curl -y"
            }
            stage("checkout") {
                // Clone OSH images
                def ref = determineRef("openstack/openstack-helm-images")
                gerrit.cloneToBranch("https://opendev.org/openstack/openstack-helm-images", ref, "${JOB_BASE_NAME}")

                // Clone aic-clcp-manifests
                def ref = determineRef("aic-clcp-manifests")
                dir ("minimirror/mini-mirror") {
                    gerrit.cloneProject(GERRIT_CLONE_URL + "/" + conf.GLOBAL_REPO, ref, REFSPEC, conf.GLOBAL_REPO, conf.JENKINS_GERRIT_MTN5_CRED_ID)
                }
            }
            stage("Download private key") {
                artifactory.download("${ARTF_PATH}", "gpgkey-private")
            }
            stage("Build") {
                dir ("minimirror/mini-mirror"){
                    withCredentials([string(credentialsId: 'mini-mirror-pass', variable: 'MINI_PASS')]) {
                    sh '''
                    REGISTRY_URI="${ARTF_DOCKER_URL}/att-comdev/" \
                    VERSION="${GERRIT_PATCHSET_REVISION}" DISTRO=ubuntu_xenial \
                    HTTP_PROXY=${HTTP_PROXY} HTTPS_PROXY=${HTTP_PROXY} \
                    APTLY_CONFIG_PATH=/aic-clcp-manifests/tools/mini-mirror/etc/aptly.conf \
                    MIRROR_SOURCE_DIR=/aic-clcp-manifests/tools/mini-mirror/sources \
                    RELEASE_SIGN_KEY_PATH=/gpgkey-private RELEASE_SIGN_KEY_PASSPHRASE=${MINI_PASS} \
                    bash build.sh
                    '''
                    }
                    sh "docker images"
                }
            }
            stage('Image Publish'){
                publish.artifactory (IMAGE, "${IMAGE_PREFIX}/${JOB_BASE_NAME}:${GERRIT_PATCHSET_REVISION}-ubuntu.${BUILD_TIMESTAMP}")
                if (GERRIT_EVENT_TYPE == 'change-merged') {
                    publish.artifactory (IMAGE, IMAGE_LATEST)
                }
            }
        }
    }
}
