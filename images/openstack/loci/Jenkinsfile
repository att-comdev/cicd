
NODE_NAME = "images-loci-${JOB_BASE_NAME}-${BUILD_NUMBER}"
NODE_TMPL = "docker/loci.yaml"

LOCI_REPO = 'https://git.openstack.org/openstack/loci.git'

DIND_IMAGE = "${ARTF_DOCKER_URL}/docker:17.07.0-dind"
NGINX_IMAGE = "${ARTF_DOCKER_URL}/nginx"

LOCAL_WEB_PORT = '8080'
LOCAL_WEB_URL = "http://172.18.0.1:${LOCAL_WEB_PORT}"

PROJECT = JOB_BASE_NAME

if (PROJECT.contains('mos')) {
    PROJECT_PREFIX = "loci/mos"
    PROJECT_SUFFIX = PROJECT.split('-')[1]
    PROJECT_REPO = "${INTERNAL_GERRIT_URL}/mos-${PROJECT_SUFFIX}"
} else {
    // openstack community repos by default
    PROJECT_REPO = "https://git.openstack.org/openstack/${PROJECT}"
    PROJECT_PREFIX = "loci/community"
}

ARTF_REPO = 'openstack'
if (env.GERRIT_EVENT_TYPE == 'patchset-created') {
    ARTF_REPO += '-patchset'
}

if (env.GERRIT_REFSPEC) {
    PROJECT_REF = GERRIT_REFSPEC
    PROJECT_VERSION = "ps${GERRIT_CHANGE_NUMBER}"
    PROJECT_BRANCH = GERRIT_BRANCH
    DISPLAY_PREFIX = GERRIT_EVENT_TYPE

} else {
    PROJECT_BRANCH = PROJECT_REF
    DISPLAY_PREFIX = "manual"
}


PROJECT_CONFIG = [
  'keystone': ['profiles': '"apache ldap"', 'packages': '"pycrypto python-openstackclient"', 'distpackages': ' '],
  'heat':     ['profiles': 'apache', 'packages': 'pycrypto', 'distpackages': 'curl'],
  'glance':   ['profiles': '"glance ceph"', 'packages': '"pycrypto python-swiftclient"', 'distpackages': ' '],
  'cinder':   ['profiles': '"cinder lvm ceph qemu"', 'packages': '"pycrypto python-swiftclient"', 'distpackages': ' '],
  'neutron':  ['profiles': '"neutron openvswitch"', 'packages': 'pycrypto', 'distpackages': ' '],
  'nova':     ['profiles': '"nova ceph openvswitch configdrive qemu apache"',
               'packages': 'pycrypto', 'distpackages': ' '],

  'mos-keystone': ['profiles': '"apache ldap"', 'packages': '"pycrypto python-openstackclient"', 'distpackages': ' '],
  'mos-heat':     ['profiles': 'apache', 'packages': 'pycrypto', 'distpackages': 'curl'],
  'mos-glance':   ['profiles': '"glance ceph qemu"', 'packages': '"pycrypto python-swiftclient"', 'distpackages': ' '],
  'mos-horizon':  ['profiles': '"horizon apache"', 'packages': '"python-ceilometerclient pycrypto"', 'distpackages': ' '],
  'mos-cinder':   ['profiles': '"cinder lvm ceph qemu"', 'packages': '"pycrypto python-swiftclient"', 'distpackages': ' '],
  'mos-neutron':  ['profiles': '"neutron openvswitch"', 'packages': 'pycrypto', 'distpackages': ' '],
  'mos-nova':     ['profiles': '"nova ceph openvswitch configdrive qemu apache"',
                   'packages': 'pycrypto', 'distpackages': ' '],
  'mos-nova-1804': ['profiles': '"nova ceph openvswitch configdrive qemu apache"',
                   'packages': 'pycrypto', 'distpackages': ' '],
  'mos-neutron-sriov': ['profiles': '"neutron linuxbridge openvswitch"',
                   'packages': 'pycrypto', 'distpackages': '"ethtool lshw"']
]


currentBuild.displayName = "#${BUILD_NUMBER} ${DISPLAY_PREFIX} ${PROJECT_BRANCH}"


// handle diffs in stable/<rel>, and <rel>-eol
if (PROJECT_BRANCH.contains('stable/')) {
    PROJECT_RELEASE = PROJECT_BRANCH.replace('stable/', '')
} else if (PROJECT_BRANCH.contains('-eol')) {
    PROJECT_RELEASE = PROJECT_BRANCH.replace('-eol', '')
} else if (PROJECT_BRANCH.contains('main/newton')) {
    PROJECT_RELEASE = PROJECT_BRANCH.replace('main/', '')
} else if (PROJECT_BRANCH.contains('master/ocata')) {
    PROJECT_RELEASE = PROJECT_BRANCH.replace('master/', '')
} else if (PROJECT_BRANCH == 'master') {
    PROJECT_RELEASE = PROJECT_BRANCH
} else {
    error("Unsupported branch/tag: ${PROJECT_BRANCH}")
}

IMAGE_BASE = "${ARTF_DOCKER_URL}/${ARTF_REPO}/${PROJECT_RELEASE}/${PROJECT_PREFIX}"

// used on merge, and for building projects (always non-ps path)
// project builds assume branch-specific requirements:latest
// note: mos will use community ocata requirements for now
WHEELS_LATEST = "${ARTF_DOCKER_URL}/openstack/${PROJECT_RELEASE}/loci/community/requirements@sha256:b07d53b6f21396e912e5e2ff5341150f2d8eee67ea462964a65c377e692a16b5"


// cmd for running Docker in Docker
DIND = 'sudo docker exec loci-build'

// docker within docker (to get latest docker version on Ubuntu 16.04)
// requires setting {"storage-driver": "overlay2"} option in docker.json
def docker_setup = {
    def opts = '--privileged --name loci-build'
    def mounts = '-v /var/lib/docker' +
        ' -v $(pwd):/opt/loci'

    sh "sudo docker run -d ${opts} ${mounts} ${DIND_IMAGE}"
    sh "${DIND} sh -cx 'apk update; apk add git'"

    withCredentials([usernamePassword(credentialsId: 'jenkins-artifactory',
            usernameVariable: 'ARTIFACTORY_USER',
            passwordVariable: 'ARTIFACTORY_PASSWORD')]) {

        opts = '-u $ARTIFACTORY_USER -p $ARTIFACTORY_PASSWORD'
        if (PROJECT.contains('mos')) {
            sh "${DIND} docker login ${opts} ${ARTF_SECURE_DOCKER_URL}"
        } else {
            sh "${DIND} docker login ${opts} ${ARTF_DOCKER_URL}"
        }
    }
}



def version_resolve = {
    // use commit hash when triggered manually
    if (!env.GERRIT_REFSPEC) {

        sh "git clone web/repo/${PROJECT}"

        dir (PROJECT) {
            sh "git fetch ../web/repo/${PROJECT} ${PROJECT_REF}"
            sh "git checkout FETCH_HEAD"
            //Can put back pretty formatting if the commit-id returned is increased to 12 
            //make sure that we have no conflicts
            def cmd = "git rev-parse HEAD"
            PROJECT_VERSION = sh(returnStdout: true, script: cmd).trim()
        }
    }
}


// local web server exposing mounted volume /opt/loci/web
// this enables localized use of git/docker artifacts
def nginx_setup = {
    sh "mkdir -p web"

    def opts = '-d -v /opt/loci/web:/usr/share/nginx/html:ro'
    def port = "-p ${LOCAL_WEB_PORT}:80"
    sh "${DIND} docker run ${opts} ${port} ${NGINX_IMAGE}"
}

def repo_clone = {
    sh 'mkdir -p web/repo'

    dir ('web/repo') {
        sh "git clone --mirror ${PROJECT_REPO} ${PROJECT}"
        sh "cd ${PROJECT} && git update-server-info"
    }
}

def repo_clone_ssh = {
    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-stage-master',
                                       keyFileVariable: 'SSH_KEY')]) {
        // wrapper for custom git ssh key
        // ssh -i $SSH_KEY $@
        withEnv(["GIT_SSH=/usr/bin/git-ssh-wrapper"]) {
            repo_clone()
        }
    }
}

def repo_mirror = {
    if (PROJECT_REPO.contains('ssh://')) {
        repo_clone_ssh()
    } else {
        repo_clone()
    }
}


def wheels_export = {
    sh "mkdir -p web/images"

    sh "${DIND} docker create --name loci-wheels ${WHEELS_LATEST}"
    sh "${DIND} docker export -o /opt/loci/web/images/wheels.tar loci-wheels"
    sh "${DIND} chmod +r /opt/loci/web/images/wheels.tar"
}


def wheels_build = {
    def args = "--build-arg FROM=${LOCI_BASE_IMAGE}" +
        " --build-arg PROJECT=${PROJECT}" +
        " --build-arg PROJECT_REF=${PROJECT_REF}" +
        " --build-arg PROJECT_REPO=${LOCAL_WEB_URL}/repo/${PROJECT}"

    def tag = "${IMAGE_BASE}/${PROJECT}:${PROJECT_VERSION}"
    ansiColor('xterm') {
        sh "${DIND} docker build ${LOCI_REPO} ${args} --tag ${tag}"
    }
    sh "${DIND} docker push ${tag}"
    
    // publish latest (branch) tag on merge
    if (env.GERRIT_EVENT_TYPE == 'change-merged') {
        sh "${DIND} docker tag ${tag} ${WHEELS_LATEST}"
        sh "${DIND} docker push ${WHEELS_LATEST}"
    }
}


def project_build = {
    def args = "--build-arg FROM=${LOCI_BASE_IMAGE}" +
        " --build-arg PROJECT=${PROJECT}" +
        " --build-arg PROJECT_REF=${PROJECT_REF}" +
        " --build-arg PROFILES=${PROJECT_CONFIG[PROJECT].profiles}" +
        " --build-arg PIP_PACKAGES=${PROJECT_CONFIG[PROJECT].packages}" +
        " --build-arg DIST_PACKAGES=${PROJECT_CONFIG[PROJECT].distpackages}" +
        " --build-arg PROJECT_REPO=${LOCAL_WEB_URL}/repo/${PROJECT}" +
        " --build-arg WHEELS=${LOCAL_WEB_URL}/images/wheels.tar"

    def tag = "${IMAGE_BASE}/${PROJECT}:${PROJECT_VERSION}"
    ansiColor('xterm') {
        sh "${DIND} docker build ${LOCI_REPO} ${args} --tag ${tag}"
    }
    // sh "${DIND} docker push ${tag}"
}

def project_build_mos = {
    def args = "--build-arg FROM=${LOCI_BASE_IMAGE}" +
        " --build-arg PROJECT=${PROJECT_SUFFIX}" +
        " --build-arg PROJECT_REF=${PROJECT_REF}" +
        " --build-arg PROFILES=${PROJECT_CONFIG[PROJECT].profiles}" +
        " --build-arg PIP_PACKAGES=${PROJECT_CONFIG[PROJECT].packages}" +
        " --build-arg DIST_PACKAGES=${PROJECT_CONFIG[PROJECT].distpackages}" +
        " --build-arg PROJECT_REPO=${LOCAL_WEB_URL}/repo/${PROJECT}" +
        " --build-arg WHEELS=${LOCAL_WEB_URL}/images/wheels.tar" +
        " --label org.label-schema.vcs-ref=${PROJECT_VERSION}" +
        " --label org.label-schema.vcs-url=${LOCAL_WEB_URL}/repo/${PROJECT}" +
        " --label org.label-schema.version=0.9.0"

    def tag = "${ARTF_SECURE_DOCKER_URL}/${PROJECT_RELEASE}/${PROJECT_PREFIX}/${PROJECT}:${PROJECT_VERSION}"
    ansiColor('xterm') {
        sh "${DIND} docker build ${LOCI_REPO} ${args} --tag ${tag}"
    }
    // todo: uncomment once repos are fixed
    sh "${DIND} docker push ${tag}"
    def cmd="${DIND} docker inspect --format='{{index .RepoDigests 0}}' ${tag}"
    def sha256 = sh(returnStdout: true, script: cmd)
    
    publish.setProperty ('jenkins-artifactory', 'clcp-manifests', "${RELEASE_CURRENT_KEY}=${sha256}")
    publish.setProperty ('jenkins-artifactory', 'clcp-manifests', "${RELEASE_STATUS_KEY}=NoStatus")
}


vm(NODE_NAME, NODE_TMPL) {

    stage('Docker Setup') {
        docker_setup()
    }

    stage('Local Repo Setup') {
        nginx_setup()
        repo_mirror()
        version_resolve()
    }

    if (PROJECT == 'requirements') {
        stage('Build Requirements') {
            wheels_build()
        }
    } else {
        stage('Wheels Export') {
            wheels_export()
        }
        stage ("Build ${PROJECT.capitalize()}") {
           if (PROJECT.contains('mos')) {
               project_build_mos()
           } else {
               project_build()
           }
        }
    }
}