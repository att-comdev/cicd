import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic

EVENT_TYPE = env.EVENT_TYPE ? env.EVENT_TYPE : 'manual'
RETRY_COUNT = env.RETRY_COUNT.toInteger()

def getProjName(String project) {
    project.split('/')[-1]
}

def getRefParamName(String project) {
    getProjName(project).toUpperCase().replace('-', '_') + "_REF"
}

reqRefParam = getRefParamName(env.REQ_PROJECT_NAME)
reqRef = env."${reqRefParam}"

if (REQUIREMENTS_LOCI_IMAGE && (DEPENDENCY_LIST || reqRef)) {
    error('Can not specify REQUIREMENTS_LOCI_IMAGE with DEPENDENCY_LIST ' +
          'or ${reqRefParam}')
}

stage("${REQ_PROJECT_NAME} image build") {
    if (DEPENDENCY_LIST || reqRef) {
        reqRef = reqRef ? reqRef : BRANCH
        parameters = [
            stringParam(name: 'DEPENDENCY_LIST', value: DEPENDENCY_LIST),
            stringParam(name: 'EVENT_TYPE', value: EVENT_TYPE),
            stringParam(name: 'PROJECT_REF', value: reqRef),
        ]
        print "Building image for ${REQ_PROJECT_NAME} with ${parameters}"
        retry(RETRY_COUNT) {
            job = build(
                job: "${JOB_BASE}/${REQ_PROJECT_NAME}",
                wait: true,
                propagate: true,
                parameters: parameters
            )
        }
        REQUIREMENTS_LOCI_IMAGE = job.getBuildVariables()["IMAGE_SHA"]
    } else {
        print ("Skipping build for ${REQ_PROJECT_NAME} as there " +
               'are no related changes.')
    }
}

PROJECT_MAP = new JsonSlurperClassic().parseText(env.PROJECT_MAP)
results = [:]
runningSet = [:]
PROJECT_MAP.each { projectName, buildTypes ->
    if (projectName == REQ_PROJECT_NAME) { return }
    // Don't build component image with both default refspec and
    // default requirement image
    if (!(REQUIREMENTS_LOCI_IMAGE || env."${getRefParamName(projectName)}")) {
        print ("Skipping build for ${projectName} as there are no " +
               "related changes.")
        return
    }
    if (!buildTypes) {
        buildTypes = [projectName.split('-')[-1]]
    }
    buildTypes.each { buildType ->
        runningSet[buildType] = {
            stage("mos-${buildType} image build") {
                projectRef = env."${getRefParamName(projectName)}"
                projectRef = projectRef ? projectRef : BRANCH
                parameters = [
                    stringParam(name: 'PROJECT_REF', value: projectRef),
                    stringParam(name: 'REQUIREMENTS_LOCI_IMAGE',
                                value: REQUIREMENTS_LOCI_IMAGE),
                    stringParam(name: 'EVENT_TYPE', value: EVENT_TYPE),
                ]
                print "Building image for ${buildType} with ${parameters}"
                retry(RETRY_COUNT) {
                    job = build(
                        job: "${JOB_BASE}/mos-${buildType}",
                        parameters: parameters,
                        propagate: true
                    )
                    results[buildType] = job
                }
            }
        }
    }
}

parallel runningSet

overrideImages = [:]
results.each { _, job ->
    buildVars = job.getBuildVariables()
    overrideImages[buildVars["LOCI_IMAGE_VAR"]] = buildVars["IMAGE_SHA"]
}
overrideImagesJSON = JsonOutput.toJson(overrideImages)
parameters = [
    stringParam(name: "OVERRIDE_IMAGES", value: overrideImagesJSON)
]

images = ""
overrideImages.each { k, v -> images += "${k}=${v}\n"}
if (REQUIREMENTS_LOCI_IMAGE) {
    images += "REQUIREMENTS_LOCI=${REQUIREMENTS_LOCI_IMAGE}"
}
currentBuild.description = images

if (EVENT_TYPE != 'change-merged') {
    stage("Test Deployment") {
        retry(RETRY_COUNT) {
            job = build(
                job: "${JOB_BASE}/TestDeploymentPipeline",
                parameters: parameters,
                wait: true,
                propagate: true
            )
        }
    }
}

env.IMAGES = images
