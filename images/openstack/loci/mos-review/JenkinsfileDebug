import jenkins.model.Jenkins
import com.att.nccicd.config.conf as config
import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic

conf = new config(env).CONF
RETRY_COUNT = RETRY_COUNT.toInteger()

LABEL = "DebugDeployment-${GERRIT_CHANGE_OWNER_EMAIL.split('@')[0]}"
LAUNCH_NODE = 'jenkins-node-launch'

json = new JsonSlurperClassic()

projectList = json.parseText(PROJECT_LIST)
validCharts = []
projectList.each { validCharts.add(it.split("-")[-1]) }

if (GERRIT_CHANGE_OWNER_EMAIL != GERRIT_EVENT_ACCOUNT_EMAIL) {
    reply("Only change owner is allowed to execute debug commands")
}


if (GERRIT_BRANCH == conf.OCATA_BRANCH) {
    RELEASE = 'ocata'
} else if (GERRIT_BRANCH == conf.STEIN_BRANCH) {
    RELEASE = 'stein'
} else {
    error("Unsupported branch: ${GERRIT_BRANCH}")
}


def setPubKey() {
    node (LABEL) {
        if (fileExists("${HOME}/key_set")) { return }
        cmd = ("unset NO_PROXY; unset no_proxy; " +
               "curl https://${INTERNAL_GERRIT_URL}/accounts/" +
               "${GERRIT_CHANGE_OWNER_EMAIL}|tail -n +2")
        accountId = json.parseText(
            sh(returnStdout: true, script: cmd)
        )._account_id.toString()
        sshagent ([INTERNAL_GERRIT_KEY]) {
            sh "git clone ${INTERNAL_GERRIT_SSH}/All-Users ||:"
            accountId = accountId[-2..-1] << "/" << accountId
            dir ("All-Users") {
                sh "git fetch origin refs/users/${accountId} && git checkout FETCH_HEAD"
                sh "echo \"${readFile('authorized_keys')}\" >> ${HOME}/.ssh/authorized_keys"
            }
        }
        sh "rm -rf All-Users; touch ${HOME}/key_set"
    }
}


def getHost(name) {
  return Jenkins.getInstance().getComputer(name).getNode().getLauncher().getHost()
}


def waitForNode(limit) {
    def i = 0
    while (!nodesByLabel(label: LABEL)) {
        if (i >= limit) {
            return false
        }
        sleep 60
        i ++
    }
    return true
}


def waitForDeployment(limit) {
    def i = 0
    try {
        node (LABEL) {
            dir("${WORKSPACE}/../DebugDeploymentPipeline") {
                while (!fileExists("config")) {
                    if (i >= limit) {
                        return false
                    }
                    sleep 60
                    i ++
                }
            }
        }
    } catch (Exception e) {
        return false
    }
    return true
}


def deploy = {
    build(
        job: "${JOB_BASE}/DebugDeploymentPipeline",
        parameters: [
            stringParam(name: 'RELEASE', value: RELEASE),
            stringParam(name: 'LABEL', value: LABEL)
        ],
        wait: false
    )
}

def reply (message) {
    node (LAUNCH_NODE){
        sshagent([INTERNAL_GERRIT_KEY]) {
            sh ("ssh -p ${GERRIT_PORT} ${INTERNAL_GERRIT_USER}@${GERRIT_HOST} " +
                "gerrit review --project \"${GERRIT_PROJECT}\" " +
                "--message '\"${message}\"' '${GERRIT_PATCHSET_REVISION}'")
        }
    }
}

comment = new String(GERRIT_EVENT_COMMENT_TEXT.decodeBase64())
commands = []
(comment =~ /debug(.*)/).each {
    commands.add(it[1].trim())
}
if (commands.size() > 1) {
    message = "You may not specify more than 1 command at a time"
    reply(message)
    error(message)
}
args = commands[0].split()
command = args[0]
params = []
if (args.size() > 1) {
    params = args[1..-1]
}


def help = { _ ->
    reply("help")
}


def stop = { params ->
    if (params) {
        reply ("init does not take any arguments")
        error("Wrong parameters")
    }
    if (!nodesByLabel(label: LABEL)) {
        msg = "stop: environment does not exist"
        reply(msg)
        error(msg)
    }
    node(LABEL) {
        sh "sudo rm -rf ../DebugDeploymentPipeline"
    }
    sleep 60
    reply("stop: environment is terminated")
}


def init = { params ->
    if (params) {
        reply ("init does not take any arguments")
        error("Wrong parameters")
    }
    if (waitForNode(4)) {
        ip = getHost(LABEL)
        reply("init: Environment already exists or being deployed. You may access " +
              "it with:\nssh ubuntu@${ip}\nusing your Gerrit key")
        error("Environment already exists")
    }
    reply("init: Initiating a deployment of environment. " +
          "Approximate waiting time: 30 minutes")
    deploy()
    if (!waitForNode(10)) {
        reply("init: Failed to create environment. Please try again or contact " +
              "CI/CD team")
        stop([])
    }
    if (waitForDeployment(30)) {
        setPubKey()
        ip = getHost(LABEL)
        reply("init: Environment deployment is successfully finished. " +
              "You may access it with:\n\nssh ubuntu@${ip}\n\nusing your Gerrit key")
    } else {
        reply("init: Failed to create environment. Please try again or contact " +
              "CI/CD team")
        error("Deployment failed")
        stop([])
    }
}


def populateNamedParams(paramName, args, storage) {
    while (true) {
        index = args.findIndexOf { key -> key == paramName }
        if (index < 0) {
            break
        }
        args.remove(index)
        if (args.size() < index + 1) {
            error("Unable to parse parameters: ${paramName}")
        }
        storage.add(args[index])
        args.remove(index)
    }
}

def parseArgs(args, positional, named) {
    def params = [:]
    named.each {
        params[it] = []
        populateNamedParams("--${it}", args, params[it])
    }
    arg = args.find { key -> key =~ /^--.*/ }
    if (arg) {
        error("Not recoginzed parameter: ${arg}")
    }
    positional.each {
        def arg = null
        if (args) {
            arg = args[0]
            args.remove(0)
        }
        params[it] = arg
    }
    if (args) {
        error("Not recognized arguments: ${args}")
    }
    return params
}


def add = { args ->
    if (!nodesByLabel(label: LABEL)) {
        msg = "add: environment is not ready or does not exist"
        reply(msg)
        error(msg)
    }
    def positional = ['chart', 'component', 'ref']
    def named = ['tag', 'exclude-tag']
    try {
        params = parseArgs(args, positional, named)
    } catch (Exception e) {
        reply("Error occured while parsing arguments:\n${e}")
        throw(e)
    }
    if (!params.chart) {
        if (projectList.contains(GERRIT_PROJECT)) {
            params.chart = GERRIT_PROJECT.split('-')[-1]
            params.component = GERRIT_PROJECT
        } else {
            msg = "Invalid arguments. No valid chart found"
            reply(msg)
            error(msg)
        }
    }
    if (!validCharts.contains(params.chart)) {
        msg = "Invalid chart. Valid charts: ${validCharts}"
        reply(msg)
        error(msg)
    }
    params.ref = params.ref ?: (params.component == GERRIT_PROJECT ?
                                GERRIT_REFSPEC : 'master')
    if (params['tag'] && params['exclude-tag']) {
        msg = "You may not specify both --tag and --exclude-tag"
        reply(msg)
        error(msg)
    }
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline") {
            while (!fileExists("config")) {
                sleep 60
            }
            while (fileExists('lock')) { sleep 1 }
            sh "touch lock"
            dir ("config") {
                def data = json.parseText(
                    new String((readFile("config")).trim().decodeBase64())
                )
                def oldConf = data.config ?: [:]
                def newConf = oldConf.clone()
                def chartConfig = oldConf[params.chart] ?: [:]
                def defaultTagConfig = chartConfig.default ?: [:]
                def chartOverridesConfig = chartConfig.overrides ?: [:]
                if (params['tag']) {
                    params['tag'].each {
                        def tagConfig = chartOverridesConfig[it] ?: defaultTagConfig.clone()
                        tagConfig[params.component] = params.ref
                        chartOverridesConfig[it] = tagConfig
                        if (tagConfig == defaultTagConfig) {
                            chartOverridesConfig.remove(it)
                        }
                    }
                } else {
                    params['exclude-tag'].each {
                        chartOverridesConfigConfig[it] = (
                            chartOverridesConfig[it] ?: defaultTagConfig.clone()
                        )
                    }
                    defaultTagConfig[params.component] = params.ref
                    chartOverridesConfig.each { tag, tagConfig ->
                        if (params['exclude-tag'].contains(tag)) { return }
                        tagConfig[params.component] = params.ref
                        chartOverridesConfig[tag] = tagConfig
                    }
                }
                chartOverridesConfig.each { tag, tagConfig ->
                    if (tagConfig == defaultTagConfig) {
                        chartOverridesConfig.remove(it)
                    }
                }
                chartConfig.default = defaultTagConfig
                chartConfig.overrides = chartOverridesConfig
                newConf[params.chart] = chartConfig
                print newConf.toString()

                deathTime = (System.currentTimeMillis() + 7200000).toString()
                deattTimeReadable = new Date(DeathTime).format("yyyy-MM-dd HH:mm:ss 'UTC'"))
                writeFile(file: "deathTime", text: deathTime.bytes.encodeBase64().toString())
                if (oldConf != newConf) {
                    data.config = newConf
                    data = JsonOutput.toJson(data)
                    writeFile(file: "config", text: data.bytes.encodeBase64().toString())
                    sh "git add config; git commit -m 'Update from ${GERRIT_REFSPEC}'"
                    revision = sh (returnStdout: true, script: "git rev-parse HEAD").trim()
                    reply("New configuration version ${revision} is created:\n" +
                          "${newConf}\n\nType 'debug apply' to apply it.\n"
                          "New death time: ${deattTimeReadable}")
                } else {
                    reply("No changes in configuration. New death time: ${deattTimeReadable}")
                }
            }
            sh "rm lock"
        }
    }
}


def getExecutor = { cmd ->
    def result
    switch (cmd) {
        case ~/|-h|(--|)help/:
            result = help
            break
        case "init":
            result = init
            break
        case "stop":
            result = stop
            break
        case "add":
            result = add
            break
        case "remove":
            result = remove
            break
        case "apply":
            result = apply
            break
        case "switch":
            result = checkout
            break
        case "status":
            result = status
            break
        default:
            result = help
    }
    return result
}

getExecutor(command)(params)
