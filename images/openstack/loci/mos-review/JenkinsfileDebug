import jenkins.model.Jenkins
import com.att.nccicd.config.conf as config
import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic
import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions

DumperOptions options = new DumperOptions()
options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
options.setPrettyFlow(true)

yaml = new Yaml(options)

conf = new config(env).CONF
RETRY_COUNT = RETRY_COUNT.toInteger()

LABEL = "DebugDeployment-${GERRIT_CHANGE_OWNER_EMAIL.split('@')[0]}"
LAUNCH_NODE = 'jenkins-node-launch'

json = new JsonSlurperClassic()

projectList = json.parseText(PROJECT_LIST)
validCharts = []
projectList.each { validCharts.add(it.split("-")[-1]) }

if (GERRIT_CHANGE_OWNER_EMAIL != GERRIT_EVENT_ACCOUNT_EMAIL) {
    reply("Only change owner is allowed to execute debug commands")
}


if (GERRIT_BRANCH == conf.OCATA_BRANCH) {
    RELEASE = 'ocata'
} else if (GERRIT_BRANCH == conf.STEIN_BRANCH) {
    RELEASE = 'stein'
} else {
    error("Unsupported branch: ${GERRIT_BRANCH}")
}


def setPubKey() {
    node (LABEL) {
        if (fileExists("${HOME}/key_set")) { return }
        cmd = ("unset NO_PROXY; unset no_proxy; " +
               "curl https://${INTERNAL_GERRIT_URL}/accounts/" +
               "${GERRIT_CHANGE_OWNER_EMAIL}|tail -n +2")
        accountId = json.parseText(
            sh(returnStdout: true, script: cmd)
        )._account_id.toString()
        sshagent ([INTERNAL_GERRIT_KEY]) {
            sh "git clone ${INTERNAL_GERRIT_SSH}/All-Users ||:"
            index = (accountId.length() > 1 ? accountId[-2] : "0") + accountId[-1]
            accountId = index << "/" << accountId
            dir ("All-Users") {
                sh "git fetch origin refs/users/${accountId} && git checkout FETCH_HEAD"
                sh "echo \"${readFile('authorized_keys')}\" >> ${HOME}/.ssh/authorized_keys"
            }
        }
        sh "rm -rf All-Users; touch ${HOME}/key_set"
    }
}


def getHost(name) {
  return Jenkins.getInstance().getComputer(name).getNode().getLauncher().getHost()
}


def waitForNode(limit) {
    def i = 0
    while (!nodesByLabel(label: LABEL)) {
        if (i >= limit) {
            return false
        }
        sleep 60
        i ++
    }
    return true
}


def waitForDeployment(limit) {
    def i = 0
    try {
        node (LABEL) {
            dir("${WORKSPACE}/../DebugDeploymentPipeline") {
                while (!fileExists("config/config")) {
                    if (i >= limit) {
                        return false
                    }
                    sleep 60
                    i ++
                }
            }
        }
    } catch (Exception e) {
        return false
    }
    return true
}


def deploy = {
    build(
        job: "${JOB_BASE}/DebugDeploymentPipeline",
        parameters: [
            stringParam(name: 'RELEASE', value: RELEASE),
            stringParam(name: 'LABEL', value: LABEL)
        ],
        wait: false
    )
}


def lock () {
    dir ("${WORKSPACE}/../DebugDeploymentPipeline/config") {
        while (fileExists("lock")) { sleep 1 }
        sh "touch lock"
    }
}


def unlock () {
    dir ("${WORKSPACE}/../DebugDeploymentPipeline/config") {
        sh "rm lock"
    }
}


def reply (message) {
    node (LAUNCH_NODE){
        sshagent([INTERNAL_GERRIT_KEY]) {
            sh ("ssh -p ${GERRIT_PORT} ${INTERNAL_GERRIT_USER}@${GERRIT_HOST} " +
                "gerrit review --project \"${GERRIT_PROJECT}\" " +
                "--message '\"${message}\"' '${GERRIT_PATCHSET_REVISION}'")
        }
    }
}

comment = new String(GERRIT_EVENT_COMMENT_TEXT.decodeBase64())
commands = []
(comment =~ /debug(.*)/).each {
    commands.add(it[1].trim())
}
if (commands.size() > 1) {
    message = "You may not specify more than 1 command at a time"
    reply(message)
    error(message)
}
args = commands[0].split()
command = args[0]
params = []
if (args.size() > 1) {
    params = args[1..-1]
}


def help = { _ ->
    reply("help")
}


def assertEnvExists(cmd) {
    if (!nodesByLabel(label: LABEL)) {
        msg = "${cmd}: environment is not ready or does not exist"
        reply(msg)
        error(msg)
    }
}


def assertEnvReady(cmd) {
    assertEnvExists(cmd)
    def ready = true
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline") {
            if (!fileExists("config/config")) {
                ready = false
            }
        }
    }
    if (ready) { return }
    msg = "${cmd}: environment deployment is not finished"
    reply(msg)
    error(msg)
}


def stop = { params ->
    if (params) {
        reply ("stop does not take any arguments")
        error("Wrong parameters")
    }
    assertEnvExists("stop")
    node(LABEL) {
        sh "sudo rm -rf ../DebugDeploymentPipeline"
    }
    sleep 60
    reply("stop: environment is terminated")
}


def init = { params ->
    if (params) {
        reply ("init does not take any arguments")
        error("Wrong parameters")
    }
    if (waitForNode(4)) {
        ip = getHost(LABEL)
        reply("init: Environment already exists or being deployed. You may access " +
              "it with:\nssh ubuntu@${ip}\nusing your Gerrit key")
        error("Environment already exists")
    }
    reply("init: Initiating a deployment of environment. " +
          "Approximate waiting time: 30 minutes")
    deploy()
    if (!waitForNode(10)) {
        reply("init: Failed to create environment. Please try again or contact " +
              "CI/CD team")
        stop([])
    }
    if (waitForDeployment(30)) {
        setPubKey()
        ip = getHost(LABEL)
        reply("init: Environment deployment is successfully finished. " +
              "You may access it with:\n\nssh ubuntu@${ip}\n\nusing your Gerrit key")
    } else {
        reply("init: Failed to create environment. Please try again or contact " +
              "CI/CD team")
        error("Deployment failed")
        stop([])
    }
}


def populateNamedParams(paramName, args, storage) {
    while (true) {
        index = args.findIndexOf { key -> key == paramName }
        if (index < 0) {
            break
        }
        args.remove(index)
        if (args.size() < index + 1) {
            error("Unable to parse parameters: ${paramName}")
        }
        storage.add(args[index])
        args.remove(index)
    }
}

def parseArgs(args, positional, named) {
    try {
        def params = [:]
        named.each {
            params[it] = []
            populateNamedParams("--${it}", args, params[it])
        }
        arg = args.find { key -> key =~ /^--.*/ }
        if (arg) {
            error("Not recoginzed parameter: ${arg}")
        }
        positional.each {
            def arg = null
            if (args) {
                arg = args[0]
                args.remove(0)
            }
            params[it] = arg
        }
        if (args) {
            error("Not recognized arguments: ${args}")
        }
        return params
    } catch (Exception e) {
        reply("Error occured while parsing arguments:\n${e}")
        throw(e)
    }
}


def deepCopy(map) {
    json.parseText(JsonOutput.toJson(map))
}


def modify = { method, params ->
    if (!validCharts.contains(params.chart)) {
        msg = "Invalid chart. Valid charts: ${validCharts}"
        reply(msg)
        error(msg)
    }
    if (params['tag'] && params['exclude-tag']) {
        msg = "You may not specify both --tag and --exclude-tag"
        reply(msg)
        error(msg)
    }
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline/config") {
            lock()
            def data
            data = json.parseText(
                new String((readFile("config")).trim().decodeBase64())
            )
            def oldConf = data.config ?: [:]
            def newConf = deepCopy(oldConf)
            def chartConfig = newConf[params.chart] ?: [:]
            def defaultTagConfig = chartConfig.default ?: [:]
            def chartOverridesConfig = chartConfig.overrides ?: [:]
            if (params['tag']) {
                params['tag'].each {
                    def tagConfig = chartOverridesConfig[it] ?: defaultTagConfig.clone()
                    method(tagConfig)
                    chartOverridesConfig[it] = tagConfig
                }
            } else {
                params['exclude-tag'].each {
                    chartOverridesConfig[it] = (
                        chartOverridesConfig[it] ?: defaultTagConfig.clone()
                    )
                }
                method(defaultTagConfig)
                chartOverridesConfig.each { tag, tagConfig ->
                    if (params['exclude-tag'].contains(tag)) { return }
                    method(tagConfig)
                    chartOverridesConfig[tag] = tagConfig
                }
            }
            chartOverridesConfig.each { tag, tagConfig ->
                if (tagConfig == defaultTagConfig) {
                    chartOverridesConfig.remove(tag)
                }
            }
            if (defaultTagConfig) {
                chartConfig.default = defaultTagConfig
            } else {
                chartConfig.remove("default")
            }
            if (chartOverridesConfig) {
                chartConfig.overrides = chartOverridesConfig
            } else {
                chartConfig.remove("overrides")
            }

            if (chartConfig) {
                newConf[params.chart] = chartConfig
            } else {
                newConf.remove(params.chart)
            }

            deathTime = System.currentTimeMillis() + 7200000
            deathTimeReadable = new Date(deathTime).format(
                "yyyy-MM-dd HH:mm:ss 'UTC'")
            writeFile(
                file: "deathTime",
                text: deathTime.toString().bytes.encodeBase64().toString()
            )
            if (oldConf != newConf) {
                data.config = newConf
                data = JsonOutput.toJson(data)
                writeFile(file: "config",
                          text: data.bytes.encodeBase64().toString())
                sh "git add config; git commit -m 'Update from ${GERRIT_REFSPEC}'"
                def revision = sh (returnStdout: true,
                                   script: "git rev-parse HEAD").trim()
                reply("New configuration version ${revision} is created:\n" +
                      "${yaml.dump(newConf)}" +
                      "\n\nType <debug apply> to apply it.\n" +
                      "New death time: ${deathTimeReadable}")
            } else {
                reply("No changes in configuration. New death time: ${deathTimeReadable}")
            }
            unlock()
        }
    }
}


def processChart(params) {
    if (!params.chart) {
        if (projectList.contains(GERRIT_PROJECT)) {
            params.chart = GERRIT_PROJECT.split('-')[-1]
            params.component = GERRIT_PROJECT
        } else {
            msg = "Invalid arguments. No valid chart found"
            reply(msg)
            error(msg)
        }
    }
}


def add = { args ->
    assertEnvReady("add")
    def positional = ['chart', 'component', 'ref']
    def named = ['tag', 'exclude-tag']
    def params = parseArgs(args, positional, named)
    processChart(params)
    params.ref = params.ref ?: (params.component == GERRIT_PROJECT ?
                                GERRIT_REFSPEC : 'master')
    modify({ map -> map[params.component] = params.ref }, params)
}


def remove = { args ->
    assertEnvReady("remove")
    def positional = ['chart', 'component']
    def named = ['tag', 'exclude-tag']
    def params = parseArgs(args, positional, named)
    processChart(params)
    modify({ map -> map.remove(params.component) }, params)
}


def apply = { params ->
    if (params) {
        reply ("apply does not take any arguments")
        error("Wrong parameters")
    }
    assertEnvReady()
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline/config") {
            if (fileExists("apply")) {
                reply("Previous apply command is not yet processed.")
                error("apply already exist")
            }
            lock()
            def headRevision = sh (returnStdout: true,
                                   script: "git rev-parse HEAD").trim()

            def deployedRevision = ""
            if (!fileExists("deployedRevision")) { sleep 30; continue }
                deployedRevision = (readFile("deployedRevision")).trim()
            if (headRevision == deployedRevision) {
                reply ("Nothing to apply.\nConfiguration version " +
                       "${headRevision} is already deployed.")
                unlock()
                return
            }
            reply("Applying ${headRevision} to the environment")
            writeFile file: "config/apply", text: headRevision
            unlock()
            while (true) {
                if (!fileExists("deployedRevision")) { sleep 30; continue }
                deployedRevision = (readFile("deployedRevision")).trim()
                if (deployedRevision == headRevision) {
                    reply("Configuration version ${headRevision} is applied.")
                    return
                }
                sleep 30
            }
        }
    }
}


def checkout = { params ->
    if (params.size() != 1) {
        reply ("switch accepts exactly 1 argument")
        error("Wrong parameters")
    }
    def revision = params[0]
    assertEnvReady()
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline/config") {
            lock()
            def headRevision = sh (returnStdout: true,
                                   script: "git rev-parse HEAD").trim()
            if (revision == headRevision) {
                reply ("Coniguration version is already ${revision}")
                unlock()
                return
            }
            def status = sh (script: "git rev-parse ${revision}",
                             returnStatus: true)
            if (status) {
                reply ("${revision} not found in config repository")
                unlock()
                return
            }
            def branch = "master-${headRevision}"
            status = sh (script: "git rev-parse ${branch}",
                         returnStatus: true)
            if (status) {
                sh "git branch master-${headRevision}"
            }
            sh ("git reset --hard ${revision}")
            def data = json.parseText(
                new String((readFile("config")).trim().decodeBase64())
            )
            def dataConfig = data.config ?: [:]
            reply ("Switched configuration version to ${revision}\n" +
                   "${yaml.dump(dataConfig)}")
            unlock()
        }
    }
}


def status = { params ->
    if (params) {
        reply ("status does not take any arguments")
        error("Wrong parameters")
    }
    assertEnvReady()
    node(LABEL) {
        dir("${WORKSPACE}/../DebugDeploymentPipeline/config") {
            lock()
            if (fileExists("deployedRevision")) {
                deployedRevision = (readFile("deployedRevision")).trim()
                sh "git checkout ${deployedRevision} -- config"
                def data = json.parseText(
                    new String((readFile("config")).trim().decodeBase64()))
                sh "git reset --hard HEAD"

                def dataConfig = data.config ?: [:]
                reply ("Deployed config version ${deployedRevision}:\n" +
                       "${yaml.dump(dataConfig)}")
            } else {
                reply ("No changes are deployed.")
            }
            unlock()
        }
    }
}


def getExecutor = { cmd ->
    def result
    switch (cmd) {
        case ~/|-h|(--|)help/:
            result = help
            break
        case "init":
            result = init
            break
        case "stop":
            result = stop
            break
        case "add":
            result = add
            break
        case "remove":
            result = remove
            break
        case "apply":
            result = apply
            break
        case "switch":
            result = checkout
            break
        case "status":
            result = status
            break
        default:
            result = help
    }
    return result
}

getExecutor(command)(params)
