import com.att.nccicd.config.conf

LOCI_REPO = 'https://git.openstack.org/openstack/loci.git'

LOCAL_WEB_PORT = '8080'
LOCAL_WEB_ADDR = '172.18.0.1'
LOCAL_WEB_URL = "http://${LOCAL_WEB_ADDR}:${LOCAL_WEB_PORT}"
NO_PROXY += ",${LOCAL_WEB_ADDR}"

SEMANTIC_RELEASE_VERSION = "0.9.0"

def getOriginalCause(cause) {
    if (cause instanceof hudson.model.Cause$UpstreamCause) {
        cause = getOriginalCause(cause.getUpstreamCauses()[0])
    }
    return cause
}

def isStartedByUser() {
    cause = getOriginalCause(currentBuild.rawBuild.getCauses()[0])
    if (cause instanceof hudson.model.Cause$UserIdCause) {
        return true
    }
    return false
}

if (EVENT_TYPE != 'manual' && RESTRICT_EVENT_TYPE.toBoolean() && isStartedByUser()) {
    error "Only manual EVENT_TYPE is allowed for manual builds"
}

ARTF_REPO = 'openstack'

if (['patchset-created', 'comment-added'].contains(EVENT_TYPE)) {
    ARTF_REPO += '-patchset'
}

PROJECT_SUFFIX = env.PROJECT_NAME.split('-')[1]
BUILD_TYPE = env.BUILD_TYPE ? env.BUILD_TYPE : PROJECT_SUFFIX

if (["neutron-sriov", "nova-1804"].contains(BUILD_TYPE)) {
    LOCI_BASE_IMAGE = conf.LOCI_SRIOV_BASE_IMAGE
} else {
    LOCI_BASE_IMAGE = conf.LOCI_BASE_IMAGE
}

DISPLAY_PREFIX = "${BUILD_TYPE} ${EVENT_TYPE} ${PROJECT_BRANCH}"

currentBuild.displayName = (
    "#${BUILD_NUMBER} ${DISPLAY_PREFIX}"
)

if (PROJECT_BRANCH == 'master') {
    PROJECT_RELEASE = 'ocata'
}

REQ_PROJECT_NAME = 'mos-requirements'
PROJECT_PREFIX = "loci/mos"
PROJECT_REPO = getProjectRepoUrl(PROJECT_NAME)
PROJECT_URL = PROJECT_REPO
PROJECT_VERSION = ""

WHEELS_LATEST = (
    env.REQUIREMENTS_LOCI_IMAGE.trim() ?
    env.REQUIREMENTS_LOCI_IMAGE :
    conf.MOS_REQUIREMENTS_LOCI
)

IMAGE_BASE = ("${ARTF_SECURE_DOCKER_URL}/${ARTF_REPO}/${PROJECT_RELEASE}/" +
              "${PROJECT_PREFIX}")

DEFAULT_ARGS = [
  'FROM':         "${LOCI_BASE_IMAGE}",
  'PROJECT':      "${PROJECT_SUFFIX}",
  'PROJECT_REF':  "${PROJECT_REF}",
  'NO_PROXY':     "${NO_PROXY}",
  'http_proxy':   "${HTTP_PROXY}",
  'https_proxy':  "${HTTPS_PROXY}",
  'PROJECT_REPO': getProjectRepoInternalUrl(PROJECT_NAME),
]

// Compile ssh-agent key names and ssh config from SSH_DATA to be used
// for fetching projects to internal mirror
(KEY_NAMES, SSH_CONFIG) = compileSshData()

def getProjectRepoUrl(prj) {
    return prj.contains("ssh://") ? prj : "ssh://${INTERNAL_GERRIT_URL}:${INTERNAL_GERRIT_PORT}/${prj}"
}

def getProjectRepoInternalUrl(prj) {
    return "${LOCAL_WEB_URL}/repo/${prj}"
}

def create_mirrors(projectList, keyList) {
    sshagent(keyList) {
        dir ('web/repo') {
            projectList.each {
                (url, name) = [getProjectRepoUrl(it), it.split("/")[-1]]
                sh "git clone --mirror ${url} ${name}"
                sh "git --git-dir ${name} update-server-info"
            }
        }
    }
}

def getRequirementsImageVersion() {
    sh "${DIND} docker pull ${WHEELS_LATEST}"
    cmd = (
        "${DIND} docker inspect " +
        "--format='{{index .Config.Labels \"org.label-schema.vcs-ref\"}}' " +
        " ${WHEELS_LATEST}"
    )
    return sh(returnStdout: true, script: cmd).trim()
}

def getRevision(projectRepo, projectRef) {
    try {
        Long.parseLong(projectRef, 16)
        revision = projectRef
    } catch(java.lang.NumberFormatException ex) {
        revision = gerrit.getVersion(projectRepo, projectRef,
                                     INTERNAL_GERRIT_KEY)
    }
    return revision
}

def commit(gitArg, message) {
    sh "git ${gitArg} diff"
    sh("git ${gitArg} -c 'user.name=Jenkins' " +
       "-c 'user.email=jenkins@example.com' commit -a -m \"${message}\"")
}

// Prepare local mirrors for project and it's dependencies specified in
// upper-constraints.txt of mos-requirements project. In case of
// mos-requirements image building, replaces external 'git+ssh://' urls in
// upper-constraints.txt to point local nginx.
// Another solution here could be to maintain separate list of projects to
// mirror, that would simplify current code, but having single source of
// truth is tempting
def prepare_local_mirrors = {
    projectList = [PROJECT_NAME]
    // We always need requirements project as upper-constraints.txt is
    // a single source of truth of a dependeny list
    if (!PROJECT_NAME.contains('requirements')) {
        projectList.add(REQ_PROJECT_NAME)
    }
    sh 'mkdir -p web/repo'
    create_mirrors(projectList, [INTERNAL_GERRIT_KEY])
    sh 'mkdir -p worktree'
    gitArg = "--git-dir web/repo/${REQ_PROJECT_NAME} --work-tree worktree"
    // Pick ref for requirements project from requirements image we build
    // current image with
    // PROJECT_REF is not provided for dependency review, default is used
    requirementsRef = (PROJECT_NAME.contains('requirements') ? PROJECT_REF :
                       getRequirementsImageVersion())
    sh "git ${gitArg} checkout ${requirementsRef}"
    // Creating a list of ssh dependency urls from upper-constraints.txt
    sshDependencyList = []
    uc_path = 'worktree/upper-constraints.txt'
    upperConstraints = readFile uc_path
    (upperConstraints =~ /git\+(ssh:\/\/.*?\/.*?)@.*/).each {
        sshDependencyList.add(it[1])
    }
    if (sshDependencyList) {
        create_mirrors(sshDependencyList, KEY_NAMES)
    }

    // if we build requirements image, replace external urls to point nginx in
    // upper-constraints.txt and replace PROJECT_REF build argument
    // Also replace revisions for components in OVERRIDE_DEPENDENCY_LIST
    // if provided
    if (!PROJECT_NAME.contains('requirements')) { return }
    OVERRIDE_DEPENDENCY_LIST = env.DEPENDENCY_LIST.split()
    if (!(OVERRIDE_DEPENDENCY_LIST || sshDependencyList)) { return }

    sh "git ${gitArg} checkout -b local"
    DEFAULT_ARGS['PROJECT_REF'] = 'local'

    OVERRIDE_DEPENDENCY_LIST.each {
        (depName, depRef) = it.split(':')
        depRev = getRevision(getProjectRepoUrl(depName), depRef)
        // Groovy does not support look-behind with undefined maximum length
        upperConstraintsUpdated = upperConstraints.replaceAll(
            "(?<=git\\+(ssh|https)://.{0,30}/${depName}@).*(?=#.*)", depRev)
    }
    if (upperConstraintsUpdated != upperConstraints) {
        upperConstraints = upperConstraintsUpdated
        writeFile file: uc_path, text: upperConstraints
        commit(gitArg, "Override dependency revisions")
    }

    upperConstraintsUpdated = upperConstraints.replaceAll(
        "((?<=git\\+)ssh://.*(?=/.+@))", "${LOCAL_WEB_URL}/repo")
    if (upperConstraintsUpdated != upperConstraints) {
        upperConstraints = upperConstraintsUpdated
        writeFile file: uc_path, text: upperConstraints
        commit(gitArg, "Switch to local urls")
    }

    sh "git ${gitArg} update-server-info"
}

def compileSshData() {
    sshConfig = ""
    keys = []
    parseSshData().each { entry ->
        sshConfig += "Host $entry.value.resource\n" +
                     "User $entry.value.user\n"
        keys.add(entry.key)
    }
    return [keys, sshConfig]
}

// Parse json containing
// {'<credential_name>': {'user': '<user>', 'resource': '<resource>'}}, ...}
// The source of data what credentials to use in ssh-agent with what user
// to what resource
def parseSshData() {
    return new groovy.json.JsonSlurper().parseText(SSH_DATA)
}

def buildLociMos(projConfArgs = null, wheelArgs = null) {

    sh "${DIND} docker pull ${LOCI_BASE_IMAGE}"
    def cmd = ("${DIND} docker inspect --format='{{index .RepoDigests 0}}' " +
               "${LOCI_BASE_IMAGE}")
    def base_sha256 = sh(returnStdout: true, script: cmd).trim()

    def loci_version = gerrit.getVersion(LOCI_REPO, "master")

    LOCI_REPO_PATH = "/tmp/loci"
    // Clone loci repo to apply cicd patch for tests deletion
    sh "${DIND} git clone ${LOCI_REPO} ${LOCI_REPO_PATH}"

    // Copy script for tests cleanup to docker
    data = libraryResource "cicd/remove_tests.sh"
    writeFile file: 'remove_tests.sh', text: data

    sh ("sudo docker exec " +
        "-e REMOVE_TESTS_FILE_DATA=\"\$(cat ${WORKSPACE}/remove_tests.sh)\" " +
        "${DIND_CONTAINER} sh -c 'echo \"\$REMOVE_TESTS_FILE_DATA\" > " +
        "${LOCI_REPO_PATH}/scripts/remove_tests.sh'")
    sh "${DIND} chmod +x ${LOCI_REPO_PATH}/scripts/remove_tests.sh"

    // Add tests deletion step into install scenario for loci
    sh ("${DIND} " +
        "sed -i '/clone_project.sh/a \$(dirname \$0)/remove_tests.sh' " +
        "${LOCI_REPO_PATH}/scripts/install.sh")

    def labels = " --label org.label-schema.vcs-ref=${PROJECT_VERSION}\
      --label org.label-schema.vcs-url=${PROJECT_URL}\
      --label org.label-schema.loci-ref=${loci_version}\
      --label org.label-schema.base-image=${base_sha256}\
      --label org.label-schema.vendor=\"${conf.CUSTOM_LABEL}\"\
      --label org.label-schema.version=${SEMANTIC_RELEASE_VERSION}.${BUILD_NUMBER}"

    if (!PROJECT_NAME.contains('requirements')) {
        sh "${DIND} docker pull ${WHEELS_LATEST}"
        cmd = ("${DIND} docker inspect --format='{{index .RepoDigests 0}}' " +
               "${WHEELS_LATEST}")
        def requirements_sha256 = sh(returnStdout: true, script: cmd).trim()
        labels += (" --label org.label-schema.requirements-image=" +
                   "${requirements_sha256}")
    }

    if (EVENT_TYPE == 'change-merged') {
       labels += " --label org.label-schema.vcs-event=${EVENT_TYPE}"
    }

    def argsMap = loci.mergeArgs([DEFAULT_ARGS, projConfArgs, wheelArgs])
    def args = loci.buildParameters(argsMap)
    def image_tag = ("${IMAGE_BASE}/${BUILD_TYPE}:${PROJECT_VERSION}" +
                     ".${BUILD_TIMESTAMP}")
    ansiColor('xterm') {
        sh ("${DIND} docker build --force-rm --no-cache " +
            "${LOCI_REPO_PATH} ${args} ${labels} --tag ${image_tag}")
    }
    sh "${DIND} docker push ${image_tag}"

    //publish latest (branch) tag on merge for requirements
//    if (EVENT_TYPE == 'change-merged') {
//        def image_latest = "${IMAGE_BASE}/${BUILD_TYPE}:latest"
//        sh "${DIND} docker tag ${image_tag} ${image_latest}"
//        sh "${DIND} docker push ${image_latest}"
//    }

    return image_tag
}

def setKnownHosts() {
    if (env.KNOWN_HOSTS) {
        sh "mkdir -p ${HOME}/.ssh; echo \"${KNOWN_HOSTS}\" >> ${HOME}/.ssh/known_hosts"
    }
}

def getDindContainerName() {
    containers = sh (script: 'docker ps --format {{.Names}}', returnStdout: true).split()
    baseName = "locibuildcont"
    i = 0
    do {
        name = baseName + "@" + i++
    } while(containers.contains(name))
    return name
}

//vm2 ('loci-bootstrap.sh',
//         'cicd-ubuntu-16.04-server-cloudimg-amd64',
//         'm1.medium',
//         '',
//         'loci',
//         false) {
node(LOCI_BUILD_SLAVE_LABEL) {
    try {
        cleanWs()
        setKnownHosts()

        // cmd for running Docker in Docker
        DIND_CONTAINER = getDindContainerName()
        DIND = "sudo docker exec ${DIND_CONTAINER}"

        stage('Docker Setup') {
            loci.runDind(ARTF_SECURE_DOCKER_URL, "jenkins-artifactory",
                         DIND_CONTAINER)
        }

        stage('Local Repo Setup') {
            loci.runNginx(DIND_CONTAINER, LOCAL_WEB_PORT)
            writeFile file: "${HOME}/.ssh/config", text: SSH_CONFIG
            PROJECT_VERSION = getRevision(PROJECT_REPO, PROJECT_REF)
            prepare_local_mirrors()
        }

        stage ("Build Project") {
            print "Building ${PROJECT_NAME.capitalize()}"
            if (PROJECT_NAME.contains('requirements')) {
                IMAGE_LOCI = buildLociMos()
            } else {
                loci.exportWheels(DIND_CONTAINER, WHEELS_LATEST)
                WHEELS_ARG = ['WHEELS': "${LOCAL_WEB_URL}/images/wheels.tar"]
                IMAGE_LOCI = buildLociMos(loci.getDependencies(BUILD_TYPE),
                                          WHEELS_ARG)
            }
            env.LOCI_IMAGE_VAR = (
                "${BUILD_TYPE.replace('-', '_').toUpperCase()}_LOCI")
            cmd = ("${DIND} docker inspect " +
                   "--format='{{index .RepoDigests 0}}' ${IMAGE_LOCI}")
            env.IMAGE_SHA = sh(returnStdout: true, script: cmd).trim()
            sh "mkdir -p ${WORKSPACE}/artifacts"
            sh "echo $IMAGE_SHA | tee -a ${WORKSPACE}/artifacts/loci_image.txt"
            archiveArtifacts 'artifacts/*'
        }
    } finally {
        try {
            sh "sudo docker stop ${DIND_CONTAINER}"
        }
        finally {
            sh "sudo docker rm -v ${DIND_CONTAINER}"
        }
    }
}
