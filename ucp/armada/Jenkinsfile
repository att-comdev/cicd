
JENKINS_VM_LAUNCH = 'local-vm-launch'

PROM_NODE_BASE = "armada-${env.BUILD_NUMBER}"
PROM_NODE_TMPL = "promenade/promenade.yaml"
ARMADA_VERSION = "0.1.0.${env.BUILD_NUMBER}"

ARTF_URL = env.ARTF_DOCKER_URL
ARTF_ARMADA_IMAGE="${ARTF_URL}/ucp/armada:${ARMADA_VERSION}"
PROM_BUNDLE = "promenade-bundle.tgz"
ARTF_PROM_BUNDLE = "ucp/armada-bundle/${ARMADA_VERSION}/${PROM_BUNDLE}"
ARTF_ARMADA_MANIFEST = "clcp-integration/region/atl-lab1/armada/openstack-helm.yaml"
PROMENADE_IMAGE="${ARTF_URL}/ucp/promenade:latest"
ARMADA_IMAGE="${ARTF_URL}/ucp/armada:${ARMADA_VERSION}"

// node info { node : [hostname, ip] }
def PROM_NODES = [ build:[], genesis:[], master1:[], master2:[], worker:[]]

// wrapper for main flow
def vms(body) {

    try {
        stage('Nodes Launch') {
            node(JENKINS_VM_LAUNCH) {
                PROM_NODES.each { key, value ->
                    vm.jenkins_vm_launch("${PROM_NODE_BASE}-${key}",
                                         "${env.HOME}/${PROM_NODE_TMPL}")
                }
            }
        }

        body()

    } catch (error) {
        slack.msg("Pipeline failed: ${error}")
        error(error)

    } finally {
        stage("Publish Jenkins Logs"){
            try{
                sh "curl -s -o ./${GERRIT_CHANGE_NUMBER}-${GERRIT_PATCHSET_NUMBER}.log ${BUILD_URL}consoleText"
                nexusArtifactUploader artifacts: [[ artifactId: 'armada',
                                                    classifier: '',
                                                    file: GERRIT_CHANGE_NUMBER+'-'+GERRIT_PATCHSET_NUMBER+'.log']],
                                                    credentialsId: 'nexus3',
                                                    groupId: 'att-comdev',
                                                    nexusUrl: '$NEXUS3_URL',
                                                    nexusVersion: 'nexus3',
                                                    protocol: 'http',
                                                    repository: 'att-comdev-jenkins-logs',
                                                    version: '$BUILD_NUMBER'
            } catch (Exception e){
                //TODO slack notify of failure to upload Jenkins logs to cicd team.
            }
        }
        stage('Nodes Destroy') {
            node(JENKINS_VM_LAUNCH) {
                PROM_NODES.each { key, value ->
                    vm.jenkins_vm_destroy("${PROM_NODE_BASE}-${key}")
                }
            }
        }
    }
}

vms {

    stage('Nodes Wait'){

        def get_hname = {
            sh(returnStdout: true, script: 'echo -n $(hostname)')
        }

        def get_ip = { iface ->
            cmd = "ifconfig ${iface} | grep 'inet addr:' | cut -d: -f2 | awk '{ print \$1}'"
            sh(returnStdout: true, script: cmd).trim()
        }

        timeout (10) {
            PROM_NODES.each { key, value ->
                node ("${PROM_NODE_BASE}-${key}") {
                    PROM_NODES."${key}" = [get_hname(), get_ip('ens3')]
                }
            }
            print " *** Prom node info ***\n${PROM_NODES}"
        }
    }

    stage('Promenade Build'){
        node("${PROM_NODE_BASE}-build"){
            gerrithub.clone("att-comdev/promenade", "*/master")
            
            checkout poll: false,
                scm: [$class: 'GitSCM',
                branches: [[name: '$GERRIT_REFSPEC']],
                doGenerateSubmoduleConfigurations: false,
                extensions: [[$class: 'RelativeTargetDirectory',
                              relativeTargetDir: "armada"]],
                submoduleCfg: [],
                userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                    url: 'https://review.gerrithub.io/att-comdev/armada']]]

            sh "sudo apt-get install -y docker.io curl"

            sh "sudo docker pull ${PROMENADE_IMAGE}"

            dir(env.WORKSPACE+"/armada"){
                sh "sudo docker build -t ${ARMADA_IMAGE} ."
                sh "sudo docker tag ${ARMADA_IMAGE} ${ARTF_ARMADA_IMAGE}"
                sh 'sudo docker images | grep armada'
                 withCredentials([usernamePassword(credentialsId: 'jenkins-artifactory',
                    usernameVariable: 'ARTIFACTORY_USER',
                    passwordVariable: 'ARTIFACTORY_PASSWORD')]) {

                    opts = '-u $ARTIFACTORY_USER -p $ARTIFACTORY_PASSWORD'

                    sh "sudo docker login ${opts} ${ARTF_URL}"
                    sh "sudo docker push ${ARTF_ARMADA_IMAGE}"
                }
            }
        }
    }

    artf = Artifactory.server 'artifactory'

    def artf_spec = { pattern, target ->
        return """
            {"files": [{
                "pattern": "${pattern}",
                "target": "${target}",
                "flat": "true"
            }]}
        """
    }

    stage('Promenade Config'){
       node("${PROM_NODE_BASE}-build"){

           def config = """
              IMAGE_ARMADA=${ARMADA_IMAGE}
              CALICO_IP_AUTODETECTION_METHOD='interface=ens3'
              GENESIS_HOSTNAME=${PROM_NODES.genesis[0]}
              GENESIS_IP=${PROM_NODES.genesis[1]}
              MASTER1_HOSTNAME=${PROM_NODES.master1[0]}
              MASTER1_IP=${PROM_NODES.master1[1]}
              MASTER2_HOSTNAME=${PROM_NODES.master2[0]}
              MASTER2_IP=${PROM_NODES.master2[1]}
              WORKER_HOSTNAME=${PROM_NODES.worker[0]}
              WORKER_IP=${PROM_NODES.worker[1]}
           """
           sh "echo '${config}' > tools/gate/config-env"

           timeout(14) {
               sh "sudo bash tools/gate/build.sh ${PROMENADE_IMAGE}"
           }

           spec = artf_spec("tools/gate/${PROM_BUNDLE}", ARTF_PROM_BUNDLE)
           artf.publishBuildInfo(artf.upload(spec))
       }
    }

    def prom_up = { hname ->

        spec = artf_spec(ARTF_PROM_BUNDLE, "")
        artf.download(spec)

        sh ("tar -xvf ${PROM_BUNDLE}")

        jn = "join-${hname}.sh"
        vn = "validate-${hname}.sh"

        if (hname == "genesis") {
            jn = "genesis.sh"
        }

        timeout (10) {
            dir("${WORKSPACE}/promenade-bundle") {
               sh ("sudo bash ${jn}")
               sh ("sudo bash ${vn}")
            }
        }
    }

    stage('Genesis Up'){
        node("${PROM_NODE_BASE}-genesis") {
            prom_up("genesis")
        }
    }
    parallel (
        "Join Master1" : {
             node("${PROM_NODE_BASE}-master1"){
                 stage('Master1 Join'){
                     prom_up(PROM_NODES.master1[0])
                 }
             }
         },
         "Join Master2" : {
             node("${PROM_NODE_BASE}-master2"){
                 stage('Master2 Join'){
                     prom_up(PROM_NODES.master2[0])
                 }
             }
         },
         "Worker Join" : {
             node("${PROM_NODE_BASE}-worker"){
                 stage('Worker Join'){
                     prom_up(PROM_NODES.worker[0])
                 }
             }
         }
    )

    stage('Cluster Validate'){
        node("${PROM_NODE_BASE}-genesis") {
            timeout (30) {
                dir("${WORKSPACE}/promenade-bundle") {
                   sh ('sudo bash validate-cluster.sh')
                   sh ('sudo bash final-validation.sh')
                }
            }
            sh 'sudo kubectl get pods --all-namespaces -o wide'
        }
    }

    stage('Deploy OSH'){
        node("${PROM_NODE_BASE}-genesis") {
            timeout (60) {
               //Download manifest from Artifactory
               //https://10.24.20.19:30091/artifactory/clcp-integration/region/atl-lab1/armada/openstack-helm.yaml
               spec = artf_spec(ARTF_ARMADA_MANIFEST, "")
               artf.download(spec)
               
             //  sh 'sudo -H helm init'
               
             //  docker_cmd = "sudo docker run -d --net=host --name armada -t -v /etc/genesis/armada/auth:/armada/.kube -v ${WORKSPACE}:/etc/genesis/armada/assets/charts:ro ${ARMADA_IMAGE}"
               sh 'sudo mkdir -p ~/.kube'
               sh 'sudo chown -R ubuntu:ubuntu ~/.kube'
               sh 'cp -r /etc/kubernetes/admin/pki ~/.kube/pki'
               sh 'cat /etc/kubernetes/admin/kubeconfig.yaml | sed -e \'s/\\/etc\\/kubernetes\\/admin/./\' > ~/.kube/config'

               def get = "sudo kubectl get pods -n ucp -o wide | grep tiller-deploy | awk '{print \$6 }'"
               tiller = sh(script: get, returnStdout: true).trim()
               armada_cmd = "apply /etc/genesis/armada/assets/charts/openstack-helm.yaml --tiller-host=${tiller} --tiller-port=44134"
               docker_opts = "-t -v /etc/genesis/armada/auth:/armada/.kube -v ${WORKSPACE}:/etc/genesis/armada/assets/charts:ro --net=host"
               docker_run = "sudo docker run ${docker_opts} ${ARMADA_IMAGE} ${armada_cmd}"
               status = sh(returnStatus: true, script: docker_run)
               if (status) {
                   // todo: collect logs and handle error
                   sh "exit 1"
               }
              
               if (status) {
                    sleep 120 // mariadb timeout, retry once
                    status = sh(returnStatus: true, script: docker_run)
                    if (status) {
                        // todo: collect logs and exit
                        sh "exit 1"
                    }
                }
            }
            sh 'sudo kubectl get pods --all-namespaces -o wide'
        }
    }
}