import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions;

import groovy.json.JsonSlurperClassic


JENKINS_SLAVE_BUILDER = 'genesis-builder'

GENESIS_NODE_NAME = "genesis"
GENESIS_NODE_IP = '10.24.20.100'
VMX_NODE_NAME = "vmx"
VMX_NODE_IP = '10.24.20.101'

PROMENADE_IMAGE='quay.io/attcomdev/promenade:master'
ARMADA_IMAGE='docker.io/gerrive/armada:git-bb1205f'
DRYDOCK_IMAGE='docker.io/sthussey/drydock:383969v5'

MANIFEST_PREFIX='region/atl-lab1'
PROMENADE_CFG="${MANIFEST_PREFIX}/ucp/promenade"
ARMADA_UCP_CFG="${PROMENADE_CFG}/bootstrap-armada-config.yaml"
DRYDOCK_CFG="${MANIFEST_PREFIX}/ucp/drydock.yaml"
ARMADA_OSH_CFG="${MANIFEST_PREFIX}/osh/armada.yaml"

GENESIS_TMPL = "${MANIFEST_PREFIX}/bootstrap/genesis/genesis.yaml"
VMX_TMPL = "${MANIFEST_PREFIX}/bootstrap/vmx/vmx.yaml"

SONOBUOY_CFG="${MANIFEST_PREFIX}/test/sonobuoy.yaml"



node(JENKINS_SLAVE_BUILDER) {

    // genesis.yaml
    checkout poll: false,
        scm: [$class: 'GitSCM',
            branches: [[name: '$CLCP_INTEGRATION_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [[$class: 'RelativeTargetDirectory',
                relativeTargetDir: 'clcp-integration']],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'ssh://jenkins-attcomdev@10.24.20.18:29418/clcp-integration',
                    credentialsId:'jenkins-stage-master']]]

    // funcs.groovy
    checkout poll: false,
        scm: [$class: 'GitSCM',
            branches: [[name: '$CICD_GERRIT_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [[$class: 'RelativeTargetDirectory',
                relativeTargetDir: 'cicd']],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'https://review.gerrithub.io/att-comdev/cicd']]]

    def funcs = load "${WORKSPACE}/cicd/integration/genesis-integration/funcs.groovy"

    funcs.jenkins_slave_destroy(GENESIS_NODE_NAME)
    funcs.jenkins_slave_launch(GENESIS_NODE_NAME,
        "${WORKSPACE}/clcp-integration/${GENESIS_TMPL}", GENESIS_NODE_IP)

    funcs.jenkins_slave_destroy(VMX_NODE_NAME)
    funcs.jenkins_slave_launch(VMX_NODE_NAME,
        "${WORKSPACE}/clcp-integration/${VMX_TMPL}", VMX_NODE_IP)
}


//// ipmi utils

def ipmi_power_off = {
    withCredentials([usernamePassword(credentialsId: 'integration-ipmi',
                                      usernameVariable: 'IPMI_USERNAME',
                                      passwordVariable: 'IPMI_PASSWORD')]) {
        for (ip = 11; ip <= 14; ip++) {
            opts = "-I lanplus -H 10.23.104.${ip} -U \$IPMI_USERNAME -P \$IPMI_PASSWORD"
            sh ("ipmitool ${opts} chassis power off")
        }
    }
}

stage("Genesis Get Ready") {
    timeout (10) {
        node(GENESIS_NODE_NAME) {
            sh 'echo "Welcome $(hostname)"'
        }
    }
}

stage("Genesis Prepare") {
    node(GENESIS_NODE_NAME) {
        checkout poll: false,
            scm: [$class: 'GitSCM',
            branches: [[name: '$CLCP_INTEGRATION_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'ssh://jenkins-attcomdev@10.24.20.18:29418/clcp-integration',
                    credentialsId:'jenkins-stage-master']]]

        ipmi_power_off()

        // keys added to drydock config
        sh 'ssh-keygen -f genesis-id_rsa -N ""'
    }
}

def dump_opts = {
    // add explicit start (---) to documents
    DumperOptions opts = new DumperOptions();
    opts.setExplicitStart(true);
    return opts
}

def dump_yaml = { cfg ->
    return new Yaml(dump_opts()).dump(cfg);
}

def dump_yaml_all = { cfg ->
    return new Yaml(dump_opts()).dumpAll(cfg.iterator());
}


def index_seek = { cfg, val ->
    def index = -1;
    cfg.eachWithIndex { v, i ->
        if (v.metadata.name == val) {
            index = i
            return true // index found
        }
    }
    return index
}


stage("Config Overrides") {
    node(GENESIS_NODE_NAME) {

        //// prmenade genesis config

        def promcfg = readYaml file: "${PROMENADE_CFG}/genesis-config.yaml"
        promcfg.data.images.armada = ARMADA_IMAGE

        writeFile file: "${PROMENADE_CFG}/genesis-config.yaml", text: dump_yaml(promcfg)


        //// armada bootstrap

        def armcfg = readYaml file: "${ARMADA_UCP_CFG}"
        def i = index_seek(armcfg, 'drydock')

        armcfg[i].data.values.images.tags.drydock = DRYDOCK_IMAGE
        armcfg[i].data.values.images.tags.drydock_db_sync = DRYDOCK_IMAGE

        writeFile file: "${ARMADA_UCP_CFG}", text: dump_yaml_all(armcfg)


        //// drydock site config

        def drycfg = readYaml file: "${DRYDOCK_CFG}"

        def pkey = readFile (file: "genesis-id_rsa.pub")
        def keys = drycfg[0].spec.authorized_keys
        keys.add(pkey)
        drycfg[0].spec.authorized_keys = keys

        writeFile file: "${DRYDOCK_CFG}", text: dump_yaml_all(drycfg)
    }
}


node(GENESIS_NODE_NAME) {

    stage ("Promenade Gen Config") {
        opts = '--rm -t -w /target -v $(pwd):/target'
        cmd = "promenade generate-certs -o ${PROMENADE_CFG}/ ${PROMENADE_CFG}/*.yaml"
        sh "sudo docker run ${opts} ${PROMENADE_IMAGE} ${cmd}"

        sh "mkdir -p promenade-bundle"
        cmd = "promenade build-all --validators -o promenade-bundle ${PROMENADE_CFG}/*.yaml"
        sh "sudo docker run ${opts} ${PROMENADE_IMAGE} ${cmd}"
    }

    stage ("Promenade Deploy k8s") {

        dir ("promenade-bundle") {
            timeout (30) {
                sh "sudo bash genesis.sh"
                sh "sudo bash validate-genesis.sh"
            }
        }

        // all pods expected to be in running state
        sh "sudo kubectl get pods --all-namespaces -o wide"
    }
}


//// maas utils
def maas_import_wait = {
    timeout (10) {
        cmd = 'kubectl get pods -n ucp |grep maas-import'
        while (!sh(returnStatus: true, script: cmd)) sleep 30
    }

    sleep 60 // wait for rack sync
}


//// drydock utils

def drydock_cmd_run = { cmd ->

    drydock_env = "-e OS_USERNAME=drydock" +
        " -e OS_PASSWORD=password" +
        " -e OS_AUTH_URL=http://keystone-api.ucp.svc.cluster.local:80/v3" +
        " -e OS_PROJECT_NAME=service" +
        " -e OS_PROJECT_DOMAIN_NAME=default" +
        " -e OS_USER_DOMAIN_NAME=default" +
        " -e DD_URL=http://drydock-api.ucp.svc.cluster.local:9000" +
        " -e LC_ALL=C.UTF-8" +
        " -e LANG=C.UTF-8"

    drydock_opts = "-v \$(pwd):/target --rm -t --net=host --entrypoint \"drydock\""
    drydock_cmd = "sudo docker run ${drydock_opts} ${drydock_env} ${DRYDOCK_IMAGE}"

    response = sh(returnStdout: true, script: "${drydock_cmd} ${cmd}")
    return new JsonSlurperClassic().parseText(response)
}


def drydock_task_show = { task ->
    return drydock_cmd_run("task show --task-id=${task}")
}


def drydock_task_create = { design, action, interval ->

    ansiColor('xterm') {
        task = drydock_cmd_run("task create --design-ref=${design} -a ${action}")
    }

    def status = task.status
    timeout (interval) {
        while (status != 'complete') {
            sleep interval
            r = drydock_task_show(task.task_id)
            status = r.status
            print "task -> status: ${r.status}, action: ${r.action}"
        }
    }

    r = drydock_task_show(task.task_id).result
    print "task -> status: ${r.status}, result: ${r.result}"

    if (r.status != 'success' && r.status != 'partial_success') {
        print "Failed to execute Drydock task ${task}"
        sh "exit 1"
    }
}


def drydock_web_server = { port ->
    // feature gap: run nginx for hosting drydock YAMLs
    // this is hack before Artifactory or Deckhand can host YAMLs
    def mp = "${WORKSPACE}/${MANIFEST_PREFIX}/ucp"
    sh "sudo docker run -d -v ${mp}:/usr/share/nginx/html -p ${port}:80 nginx"
    return "http://${GENESIS_NODE_IP}:${port}/drydock.yaml"
}


//// drydock provisioning

node(GENESIS_NODE_NAME) {

    stage ("MaaS Import") {
        maas_import_wait(30)
    }

    def design = drydock_web_server('6880')

    da = ['verify_site', 'prepare_site', 'prepare_nodes', 'deploy_nodes']
    da.each {
        stage ("Drydock (${it})") {
           drydock_task_create (design, it, 40)
        }
    }
}


node(GENESIS_NODE_NAME) {
    stage('Site Config Publish') {

        sh "tar cvzf site-config.tar.gz ${MANIFEST_PREFIX}"

        spec = """
            {"files": [{
                "pattern": "site-config.tar.gz",
                "target": "ucp/integration/${JOB_BASE_NAME}/${BUILD_NUMBER}/"
            }]}"""

        artf = Artifactory.server 'artifactory'
        artf.publishBuildInfo(artf.upload(spec))
    }
}


node(GENESIS_NODE_NAME) {
    stage('Build Log Publish') {
        sh "wget ${BUILD_URL}/consoleText"
        sh 'tar cvzf consoleText.tar.gz consoleText'

        spec = """
            {"files": [{
                "pattern": "consoleText.tar.gz",
                "target": "ucp/integration/${JOB_BASE_NAME}/${BUILD_NUMBER}/"
            }]}"""

        artf = Artifactory.server 'artifactory'
        artf.publishBuildInfo(artf.upload(spec))
    }
}


//// armada install openstack

node(GENESIS_NODE_NAME) {

    // todo: cluster not deployed
    // wait on drydock/promenade integration to join nodes
    return

    stage ("Armada Apply") {

        // todo: likely need to setup k8s config

        armada_cmd = "apply /target/${ARMADA_OSH_CFG} --tiller-host=${GENESIS_NODE_IP} --tiller-port=44134"
        docker_opts = "-t -v ~/.kube:/armada/.kube -v \$(pwd):/target --net=host"
        docker_cmd = "sudo docker run ${docker_opts} ${ARMADA_IMAGE} ${armada_cmd}"

        status = sh(returnStatus: true, script: docker_cmd)
        if (status) {
          // todo: collect logs and handle error
            sh "exit 1"
        }
    }
}


if (SONOBUOY_ENABLED) {
    node(GENESIS_NODE_NAME) {

        stage('Sonobuoy E2E') {
            sh 'mkdir -p /tmp/sonobuoy' // test results

            sh "cat ${SONOBUOY_CFG} |kubectl apply -f -"

            timeout (12) {
                cmd = 'kubectl get pods -n heptio-sonobuoy |grep 1/1'
                while (sh(returnStatus: true, script: cmd)) sleep 30
            }

            timeout (120) {
                cmd = 'kubectl get pods -n heptio-sonobuoy |grep 1/1'
                while (!sh(returnStatus: true, script: cmd)) sleep 300
            }

            sh 'mkdir -p results'
            sh 'tar xf /tmp/sonobuoy/*.tar.gz -C results'

            junit 'results/plugins/e2e/results/junit_01.xml'
        }

        stage('Sonobuoy Publish') {
            spec = """
                {"files": [{
                    "pattern": "/tmp/sonobuoy/*.tar.gz",
                    "target": "ucp/integration/sonobuoy/${env.BUILD_NUMBER}/"
                }]}"""

            artf = Artifactory.server 'artifactory'
            artf.publishBuildInfo(artf.upload(spec))
        }
    }
}

