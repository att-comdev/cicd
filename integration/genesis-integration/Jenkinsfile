import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions;

import groovy.json.JsonSlurperClassic


JENKINS_SLAVE_BUILDER = 'genesis-builder'

GENESIS_NODE_NAME = "genesis"
GENESIS_NODE_IP = '10.24.20.100'
VMX_NODE_NAME = "vmx"
VMX_NODE_IP = '10.24.20.101'

PROMENADE_IMAGE='quay.io/attcomdev/promenade:master'
ARMADA_IMAGE='quay.io/attcomdev/armada:master'

DRYDOCK_IMAGE='10.24.20.19:30092/cicd/ucp/ks3019/drydock:ps380732v12'
DRYDOCK_CHART_REPO='https://github.com/sh8121att/helm_charts'
DRYDOCK_CHART_BRANCH='master'

// site manifest repos structure
MANIFEST_PREFIX='region/atl-lab1'
PROMENADE_CFG="${MANIFEST_PREFIX}/ucp/promenade"
ARMADA_UCP_CFG="${PROMENADE_CFG}/bootstrap-armada-config.yaml"
DRYDOCK_CFG="${MANIFEST_PREFIX}/ucp/drydock.yaml"
ARMADA_OSH_CFG="${MANIFEST_PREFIX}/osh/armada.yaml"

GENESIS_TMPL = "${MANIFEST_PREFIX}/genesis/bootstrap/genesis.yaml"
VMX_TMPL = "${MANIFEST_PREFIX}/vmx/vmx.yaml"


node(JENKINS_SLAVE_BUILDER) {

    // genesis.yaml
    checkout poll: false,
        scm: [$class: 'GitSCM',
            branches: [[name: '$CLCP_INTEGRATION_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [[$class: 'RelativeTargetDirectory',
                relativeTargetDir: 'clcp-integration']],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'ssh://jenkins-attcomdev@10.24.20.18:29418/clcp-integration',
                    credentialsId:'jenkins-stage-master']]]

    // funcs.groovy
    checkout poll: false,
        scm: [$class: 'GitSCM',
            branches: [[name: '$CICD_GERRIT_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [[$class: 'RelativeTargetDirectory',
                relativeTargetDir: 'cicd']],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'https://review.gerrithub.io/att-comdev/cicd']]]

    def funcs = load "${WORKSPACE}/cicd/integration/genesis-integration/funcs.groovy"

    funcs.jenkins_slave_destroy(GENESIS_NODE_NAME)
    funcs.jenkins_slave_launch(GENESIS_NODE_NAME,
        "${WORKSPACE}/clcp-integration/${GENESIS_TMPL}", GENESIS_NODE_IP)

    funcs.jenkins_slave_destroy(VMX_NODE_NAME)
    funcs.jenkins_slave_launch(VMX_NODE_NAME,
        "${WORKSPACE}/clcp-integration/${VMX_TMPL}", VMX_NODE_IP)
}


//// ipmi utils

def ipmi_power_off = {
    withCredentials([usernamePassword(credentialsId: 'integration-ipmi',
                                      usernameVariable: 'IPMI_USERNAME',
                                      passwordVariable: 'IPMI_PASSWORD')]) {
        for (ip = 11; ip <= 14; ip++) {
            opts = "-I lanplus -H 10.23.104.${ip} -U \$IPMI_USERNAME -P \$IPMI_PASSWORD"
            sh ("ipmitool ${opts} chassis power off")
        }
    }
}

stage("Genesis Prepare") {
    node(GENESIS_NODE_NAME) {
        checkout poll: false,
            scm: [$class: 'GitSCM',
            branches: [[name: '$CLCP_INTEGRATION_REFSPEC']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'ssh://jenkins-attcomdev@10.24.20.18:29418/clcp-integration',
                    credentialsId:'jenkins-stage-master']]]

        ipmi_power_off()

        // test ssh keys for genesis
        // these keys are added to drydock config
        sh 'ssh-keygen -f genesis-id_rsa -N ""'
    }
}


stage("Wait on Genesis") {
    timeout (10) {
        node(GENESIS_NODE_NAME) {
            sh "echo '*** Welcome Genesis ***'"
        }
    }
}


def dump_opts = {
    // add explicit start (---) to documents
    DumperOptions opts = new DumperOptions();
    opts.setExplicitStart(true);
    return opts
}

def dump_yaml = { cfg ->
    def dump = new Yaml(dump_opts()).dump(cfg);
    print dump
    return dump
}

def dump_yaml_all = { cfg ->
    def dump = new Yaml(dump_opts()).dumpAll(cfg.iterator());
    print dump
    return dump
}


def index_seek = { cfg, val ->
    def index = -1;
    cfg.eachWithIndex { v, i ->
        if (v.metadata.name == val) {
            index = i
            return true // index found
        }
    }
    return index
}


stage("Config Overrides") {
    node(GENESIS_NODE_NAME) {

        //// prmenade genesis config

        def promcfg = readYaml file: "${PROMENADE_CFG}/genesis-config.yaml"
        promcfg.data.images.armada = ARMADA_IMAGE

        writeFile file: "${PROMENADE_CFG}/genesis-config.yaml", text: dump_yaml(promcfg)


        //// armada bootstrap

        def armcfg = readYaml file: "${ARMADA_UCP_CFG}"
        def i = index_seek(armcfg, 'drydock')

        armcfg[i].data.values.images.drydock = DRYDOCK_IMAGE
        armcfg[i].data.values.images.drydock_db_sync = DRYDOCK_IMAGE
        armcfg[i].data.source.location = DRYDOCK_CHART_REPO
        armcfg[i].data.source.reference = DRYDOCK_CHART_BRANCH

        writeFile file: "${ARMADA_UCP_CFG}", text: dump_yaml_all(armcfg)


        //// drydock site config

        def drycfg = readYaml file: "${DRYDOCK_CFG}"

        def pkey = readFile (file: "genesis-id_rsa.pub")
        def keys = drycfg[0].spec.authorized_keys
        keys.add(pkey)
        drycfg[0].spec.authorized_keys = keys

        writeFile file: "${DRYDOCK_CFG}", text: dump_yaml_all(drycfg)
    }
}


node(GENESIS_NODE_NAME) {
    stage ("Promenade Deploy k8s") {

        opts = '--rm -t -w /target -v $(pwd):/target'
        cmd = "promenade generate-certs -o ${PROMENADE_CFG}/ ${PROMENADE_CFG}/*.yaml"
        sh "sudo docker run ${opts} ${PROMENADE_IMAGE} ${cmd}"


        sh "mkdir -p promenade-bundle"
        cmd = "promenade build-all --validators -o promenade-bundle ${PROMENADE_CFG}/*.yaml"
        sh "sudo docker run ${opts} ${PROMENADE_IMAGE} ${cmd}"

        dir ("promenade-bundle") {
            sh "sudo bash genesis.sh"
            // sh "sudo bash validate-genesis.sh"
        }

        timeout (30) {
            cmd = 'kubectl get pods -n ucp | grep drydock | grep Running |grep -v db | grep -v ks'
            while (sh(returnStatus: true, script: cmd)) sleep 60
        }

        sh "sudo kubectl get pods --all-namespaces -o wide"
    }
}


//// maas utils
def maas_import_wait = {
    return
    timeout (10) {
        cmd = 'kubectl get pods -n ucp |grep maas-import'
        while (!sh(returnStatus: true, script: cmd)) sleep 30
    }

    sleep 60 // wait for rack sync
}


//// drydock utils

def keystone_token_get = {

    keystone_image = "kolla/ubuntu-source-keystone:3.0.3"

    docker_env = "-e 'OS_AUTH_URL=http://keystone-api.ucp.svc.cluster.local:80/v3'" +
        " -e 'OS_PROJECT_DOMAIN_NAME=default'" +
        " -e 'OS_USER_DOMAIN_NAME=default'" +
        " -e 'OS_PROJECT_NAME=service'" +
        " -e 'OS_REGION_NAME=RegionOne'" +
        " -e 'OS_USERNAME=drydock'" +
        " -e 'OS_PASSWORD=password'" +
        " -e 'OS_IDENTITY_API_VERSION=3'"

    docker_opts = "--rm --net=host"
    keystone_cmd = "openstack token issue -f value -c id"
    docker_cmd = "sudo docker run ${docker_opts} ${docker_env} ${keystone_image} ${keystone_cmd}"

    return sh(returnStdout: true, script: docker_cmd).trim()
}


def drydock_cmd_run = { token, cmd ->

    drydock_env = "-e 'DD_TOKEN=${token}'" +
        " -e 'DD_URL=http://drydock-api.ucp.svc.cluster.local:9000'" +
        " -e LC_ALL=C.UTF-8" +
        " -e LANG=C.UTF-8"

    drydock_opts = "-v \$(pwd):/target --rm -t --net=host --entrypoint \"drydock\""
    drydock_cmd = "sudo docker run ${drydock_opts} ${drydock_env} ${DRYDOCK_IMAGE}"

    response = sh(returnStdout: true, script: "${drydock_cmd} ${cmd}")
    return new JsonSlurperClassic().parseText(response)
}


def drydock_task_show = { token, task ->
    return drydock_cmd_run(token, "task show --task-id=${task}")
}


def drydock_task_create = { token, design, action, interval ->

    ansiColor('xterm') {
        task = drydock_cmd_run(token, "task create --design-ref=${design} -a ${action}")
    }

    def status = task.status
    timeout (interval) {
        while (status != 'complete') {
            sleep interval
            r = drydock_task_show(token, task.task_id)
            status = r.status
            print "task -> status: ${r.status}, action: ${r.action}"
        }
    }

    r = drydock_task_show(token, task.task_id).result
    print "task -> status: ${r.status}, result: ${r.result}"

    if (r.status != 'success' && r.status != 'partial_success') {
        print "Failed to execute Drydock task ${task}"
        sh "exit 1"
    }
}


def drydock_web_server = { port ->
    // gap: run nginx for hosting drydock YAMLs
    // this is hack before Artifactory or Deckhand can host YAMLs
    sh "sudo docker run -d -v ${WORKSPACE}:/usr/share/nginx/html -p ${port}:80 nginx"
    return "http://${GENESIS_NODE_IP}:${port}/${DRYDOCK_CFG}"
}


//// drydock provisioning

node(GENESIS_NODE_NAME) {

    stage ("MaaS Import") {
        maas_import_wait(30)
    }

    def design = drydock_web_server('6880')
    def token = keystone_token_get()

    da = ['verify_site', 'prepare_site', 'prepare_nodes', 'deploy_nodes']
    da.each {
        stage ("Drydock (${it})") {
           drydock_task_create (token, design, it, 40)
        }
    }
}


node(GENESIS_NODE_NAME) {
    stage('Site Config Publish') {

        sh "tar cvzf site-config.tar.gz ${MANIFEST_PREFIX}"

        spec = """
            {"files": [{
                "pattern": "site-config.tar.gz",
                "target": "ucp/integration/${JOB_BASE_NAME}/${BUILD_NUMBER}/"
            }]}"""

        artf = Artifactory.server 'artifactory'
        artf.publishBuildInfo(artf.upload(spec))
    }
}


node(GENESIS_NODE_NAME) {
    stage('Build Log Publish') {
        sh "wget ${BUILD_URL}/consoleText"
         sh 'tar cvzf consoleText.tar.gz consoleText'

        spec = """
            {"files": [{
                "pattern": "consoleText.tar.gz",
                "target": "ucp/integration/${JOB_BASE_NAME}/${BUILD_NUMBER}/"
            }]}"""

        artf = Artifactory.server 'artifactory'
        artf.publishBuildInfo(artf.upload(spec))
    }
}


return

// todo: promenade not yet integrated fully to deploy a cluster


//// armada install openstack

node(GENESIS_NODE_NAME) {
    stage ("Armada Apply") {

        armada_cmd = "apply /target/${ARMADA_OSH_CFG} --tiller-host=${GENESIS_NODE_IP} --tiller-port=44134"
        docker_opts = "-t -v ~/.kube:/armada/.kube -v \$(pwd):/target --net=host"
        docker_cmd = "sudo docker run ${docker_opts} ${ARMADA_IMAGE} ${armada_cmd}"

        //status = sh(returnStatus: true, script: docker_cmd)
        //if (status) {
            // todo: collect logs and handle error
        //    sh "exit 1"
        //}
    }
}


node(GENESIS_NODE_NAME) {

    stage("Sonobuoy E2E") {
        checkout poll: false,
            scm: [$class: 'GitSCM',
            branches: [[name: 'v0.9.0']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [[$class: 'RelativeTargetDirectory',
                relativeTargetDir: 'sonobuoy']],
            submoduleCfg: [],
            userRemoteConfigs: [[refspec: 'refs/changes/*:refs/changes/*',
                url: 'https://github.com/heptio/sonobuoy.git']]]

        dir ('sonobuoy') {
            sh 'RBAC_ENABLED=1 make generate' // always enabled for ucp
            sh 'kubectl apply -f examples/quickstart.yaml'

            cmd = 'kubectl get pods -n heptio-sonobuoy |grep 1/1'
            while (sh(returnStatus: true, script: cmd)) sleep 30

            // wait for no-exit in logs
            cmd = 'kubectl logs -n heptio-sonobuoy sonobuoy |grep no-exit'
            while (sh(returnStatus: true, script: cmd)) sleep 30

            sh 'kubectl logs -n heptio-sonobuoy sonobuoy' // disply for fyi
            sh 'kubectl cp heptio-sonobuoy/sonobuoy:/tmp/sonobuoy ./results -n heptio-sonobuoy'
            sh 'tar xzf ./results/*.tar.gz'
            sh 'kubectl delete -f examples/quickstart.yaml'
        }
    }

    stage('Sonobuoy Publish') {
        spec = """
            {"files": [{
                "pattern": "sonobuoy/results/*.tar.gz",
                "target": "ucp/integration/sonobuoy/${env.BUILD_NUMBER}/"
            }]}"""

        artf = Artifactory.server 'artifactory'
        artf.publishBuildInfo(artf.upload(spec))
    }
}

